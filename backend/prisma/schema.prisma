// Optimized Prisma Schema for SwarmOracle
// Based on Technical Architecture Analysis

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DATABASE_URL") // For migrations
}

model Agent {
  id                  String   @id @default(uuid())
  name                String   @db.VarChar(100)
  description         String?  @db.VarChar(500)
  platform            String   @db.VarChar(50)
  webhookUrl          String?
  capabilities        String[] // ['factual', 'predictive', 'analytical', 'creative']
  
  // Performance optimized fields
  reputationScore     Decimal  @default(100) @db.Decimal(8, 4)
  totalAnswers        Int      @default(0)
  correctAnswers      Int      @default(0)
  accuracyRate        Decimal  @default(0) @db.Decimal(5, 4)
  totalEarned         Decimal  @default(0) @db.Decimal(12, 2)
  
  // Activity tracking
  lastActiveAt        DateTime @default(now())
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  // Relations
  answers             Answer[]
  stakes              Stake[]
  critiques           Critique[]
  statistics          AgentStats?
  
  // Composite indexes for performance
  @@index([reputationScore(sort: Desc), lastActiveAt(sort: Desc)], name: "idx_agents_reputation_active")
  @@index([accuracyRate(sort: Desc), totalAnswers(sort: Desc)], name: "idx_agent_performance")
  @@index([platform, createdAt(sort: Desc)], name: "idx_agents_platform_created")
  @@map("agents")
}

// Pre-computed agent statistics for fast queries
model AgentStats {
  agentId             String   @id
  agent               Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  
  // Performance metrics
  last24hAnswers      Int      @default(0)
  last7dAccuracy      Decimal  @default(0) @db.Decimal(5, 4)
  avgConsensusWeight  Decimal  @default(0) @db.Decimal(8, 6)
  specialtyCategories Json     @default("[]")
  
  // Cache timestamps
  calculatedAt        DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@map("agent_stats")
}

model Question {
  id                  String         @id @default(uuid())
  text                String         @db.VarChar(1000)
  description         String?        @db.VarChar(2000)
  category            QuestionCategory
  status              QuestionStatus @default(OPEN)
  
  // Consensus settings
  minAnswers          Int            @default(3)
  maxAnswers          Int?           @default(100)
  consensusThreshold  Decimal        @default(0.7) @db.Decimal(3, 2)
  
  // Lifecycle timestamps
  createdAt           DateTime       @default(now())
  openUntil           DateTime?
  consensusReachedAt  DateTime?
  verifiedAt          DateTime?
  
  // Relations
  answers             Answer[]
  debateRounds        DebateRound[]
  consensusLogs       ConsensusLog[]
  consensusWeights    ConsensusWeight[]
  
  // High-frequency query optimization
  @@index([status, createdAt(sort: Desc)], name: "idx_questions_status_created")
  @@index([category, status], name: "idx_questions_category_status")
  @@index([consensusReachedAt(sort: Desc)], name: "idx_questions_consensus_reached")
  @@map("questions")
}

model Answer {
  id                  String    @id @default(uuid())
  questionId          String
  agentId             String
  question            Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  agent               Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  
  // Core content
  content             String    @db.VarChar(2000)
  reasoning           String    @db.VarChar(5000)
  confidence          Decimal   @db.Decimal(3, 2) // 0.00 to 1.00
  
  // Consensus calculation fields
  initialWeight       Decimal?  @db.Decimal(8, 6)
  finalWeight         Decimal?  @db.Decimal(8, 6)
  consensusRank       Int?
  
  // Lifecycle
  submittedAt         DateTime  @default(now())
  
  // Relations
  stakes              Stake[]
  critiques           Critique[]
  consensusWeights    ConsensusWeight[]
  
  // Consensus calculation optimization
  @@index([questionId, agentId], name: "idx_answers_question_agent")
  @@index([questionId, finalWeight(sort: Desc)], name: "idx_answers_question_weight")
  @@index([agentId, submittedAt(sort: Desc)], name: "idx_answers_agent_created")
  @@unique([questionId, agentId], name: "one_answer_per_agent")
  @@map("answers")
}

// Fast consensus calculation table
model ConsensusWeight {
  questionId          String
  answerId            String
  agentId             String
  question            Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  answer              Answer    @relation(fields: [answerId], references: [id], onDelete: Cascade)
  
  finalWeight         Decimal   @db.Decimal(8, 6)
  rank                Int
  calculatedAt        DateTime  @default(now())
  
  @@id([questionId, answerId])
  @@index([questionId, finalWeight(sort: Desc)], name: "idx_consensus_weights_question")
  @@map("consensus_weights")
}

model Stake {
  id                  String      @id @default(uuid())
  answerId            String
  agentId             String
  answer              Answer      @relation(fields: [answerId], references: [id], onDelete: Cascade)
  agent               Agent       @relation(fields: [agentId], references: [id], onDelete: Cascade)
  
  amount              Decimal     @db.Decimal(12, 2)
  status              StakeStatus @default(ACTIVE)
  
  // Lifecycle
  stakedAt            DateTime    @default(now())
  resolvedAt          DateTime?
  
  // Performance index
  @@index([answerId, status], name: "idx_stakes_answer_status")
  @@index([agentId, stakedAt(sort: Desc)], name: "idx_stakes_agent_staked")
  @@map("stakes")
}

model DebateRound {
  id                  String     @id @default(uuid())
  questionId          String
  question            Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  roundNumber         Int
  topic               String     @db.VarChar(500)
  startedAt           DateTime   @default(now())
  endedAt             DateTime?
  
  // Relations
  critiques           Critique[]
  
  // Real-time queries
  @@index([questionId, roundNumber(sort: Desc)], name: "idx_debate_rounds_question_number")
  @@unique([questionId, roundNumber], name: "unique_round_per_question")
  @@map("debate_rounds")
}

model Critique {
  id                  String      @id @default(uuid())
  debateRoundId       String
  agentId             String
  debateRound         DebateRound @relation(fields: [debateRoundId], references: [id], onDelete: Cascade)
  agent               Agent       @relation(fields: [agentId], references: [id], onDelete: Cascade)
  
  targetAnswerId      String
  targetAnswer        Answer      @relation(fields: [targetAnswerId], references: [id], onDelete: Cascade)
  
  content             String      @db.VarChar(2000)
  type                CritiqueType @default(IMPROVEMENT)
  impact              Decimal     @db.Decimal(3, 2) // Impact score 0-1
  
  createdAt           DateTime    @default(now())
  
  @@index([debateRoundId, createdAt(sort: Desc)], name: "idx_critiques_round_created")
  @@map("critiques")
}

model ConsensusLog {
  id                  String    @id @default(uuid())
  questionId          String
  question            Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  algorithm           String    @db.VarChar(50) // 'BFT', 'DPoR', 'Hybrid'
  
  // Optimized: moved large JSON to separate fields
  participantCount    Int
  confidenceLevel     Decimal   @db.Decimal(5, 4)
  
  // Consensus results (normalized)
  winningAnswerId     String?
  consensusStrength   Decimal   @db.Decimal(5, 4)
  
  // Processing metadata
  calculationTimeMs   Int
  createdAt           DateTime  @default(now())
  
  @@index([questionId, createdAt(sort: Desc)], name: "idx_consensus_logs_question")
  @@map("consensus_logs")
}

// Enums
enum QuestionStatus {
  OPEN
  DEBATING
  CONSENSUS
  VERIFIED
  CLOSED
}

enum QuestionCategory {
  FACTUAL
  PREDICTIVE
  ANALYTICAL
  CREATIVE
  TECHNICAL
}

enum StakeStatus {
  ACTIVE
  WON
  LOST
  REFUNDED
}

enum CritiqueType {
  FACTUAL_ERROR
  LOGICAL_FLAW
  MISSING_CONTEXT
  IMPROVEMENT
}